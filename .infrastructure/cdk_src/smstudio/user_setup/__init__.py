# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0
"""AWS CDK constructs for setting up SageMaker Studio Users with content
"""
# Python Built-Ins:
import os
from typing import Any, Dict, Optional, Union

# External Dependencies:
from aws_cdk import CustomResource, Duration, RemovalPolicy, Stack
import aws_cdk.aws_ec2 as aws_ec2
import aws_cdk.aws_efs as aws_efs
import aws_cdk.aws_iam as aws_iam
import aws_cdk.aws_kms as aws_kms
from aws_cdk.aws_lambda import FileSystem, ILayerVersion, LayerVersion, Runtime as LambdaRuntime
from aws_cdk.aws_lambda_python_alpha import PythonFunction
import aws_cdk.aws_logs as aws_logs
import aws_cdk.custom_resources as cr
from constructs import Construct


LAMBDA_PATH = os.path.join(os.path.dirname(__file__), "fn_user_setup")


class SMStudioUserSetupCustomResourceProvider(cr.Provider):
    """Provider (AWS Lambda) for a CFn Custom Resource for SMStudio User Profile

    If you're only creating one LCC in your stack, you probably don't need to create this
    explicitly: Just use `SageMakerStudioUserSetup` direct.
    """

    def __init__(
        self,
        scope: Construct,
        id: str,
        smcr_helper_layer: ILayerVersion,
        vpc: aws_ec2.IVpc,
        vpc_subnets: Union[aws_ec2.SubnetSelection, Dict[str, Any]],
        *,
        efs_file_system: Optional[aws_efs.IFileSystem] = None,
        efs_security_group: Optional[aws_ec2.ISecurityGroup] = None,
        log_retention: Optional[aws_logs.RetentionDays] = None,
        provider_function_env_encryption: Optional[aws_kms.IKey] = None,
        provider_function_name: Optional[str] = None,
        role: Optional[aws_iam.IRole] = None,
        total_timeout: Optional[Duration] = None,
    ) -> None:
        """Create a SMStudioUserCustomResourceProvider

        Most parameters are as per parent aws_cdk.custom_resources.Provider, with the below
        exceptions:

        Parameters
        ----------
        smcr_helper_layer :
            Shared Lambda layer with helper functions for SageMaker custom resources (see
            `cr_lambda_common`)
        efs_file_system :
            To load content onto users' home directories, you'll need to provide the EFS FileSystem
            backing the SageMaker Studio Domain: This provider will set up a root access point to
            that FS. If you don't provide it, the resource will not be able to copy content into
            users' home directories.
        efs_security_group :
            Security Group to use for access to the Studio home EFS File System (the 'outbound' EFS
            SG generated by SageMaker).
        role :
            By default, we'll create a role with required SageMaker and IAM accesses. If you
            provide your own role, you'll need to ensure these permissions are set up. This role is
            used for the Custom Resource event handler function, not the CDK CR framework function.
        """
        stack = Stack.of(scope)
        security_groups = [efs_security_group]
        if efs_file_system:
            efs_access_point = aws_efs.AccessPoint(
                scope,
                "StudioEFSAccessPoint",
                file_system=efs_file_system,
                posix_user=aws_efs.PosixUser(gid="0", uid="0"),
            )
            security_groups.append(
                aws_ec2.SecurityGroup(
                    scope,
                    "UserContentFunctionSG",
                    allow_all_ipv6_outbound=True,
                    allow_all_outbound=True,
                    description="Security group conferring public internet access to SageMaker Studio user setup Lambda",
                    vpc=vpc,
                )
            )
        else:
            efs_access_point = None
        if not role:
            inline_iam_statements = [
                aws_iam.PolicyStatement(
                    actions=[
                        "sagemaker:DescribeUserProfile",
                        "servicecatalog:AssociatePrincipalWithPortfolio",
                        "servicecatalog:DisassociatePrincipalFromPortfolio",
                        "servicecatalog:ListAcceptedPortfolioShares",
                    ],
                    resources=["*"],
                ),
            ]
            if efs_access_point:
                inline_iam_statements += [
                    aws_iam.PolicyStatement(
                        actions=["ec2:AssignPrivateIpAddresses", "ec2:UnassignPrivateIpAddresses"],
                        resources=["*"],  # (on any Network Interface)
                    ),
                    aws_iam.PolicyStatement(
                        actions=[
                            "ec2:CreateNetworkInterface",
                            "ec2:DescribeNetworkInterfaces",
                            "ec2:DeleteNetworkInterface",
                        ],
                        resources=["*"],
                        # FIXME: The provided execution role does not have permissions to call CreateNetworkInterface on EC2 (Service: Lambda, Status Code: 400, Request ID: fd91874a-fa5f-4460-a7c6-8d3daf01541c)" (RequestToken: 8e21cdd2-9d3b-952a-a49d-782dba31559e, HandlerErrorCode: InvalidRequest)
                        # resources=[
                        #     f"arn:{stack.partition}:ec2:{stack.region}:{stack.account}:network-interface/*",
                        #     *[
                        #         f"arn:{stack.partition}:ec2:{stack.region}:{stack.account}:subnet/{subnet.subnet_id}"
                        #         for subnet in vpc_subnets.subnets
                        #     ],
                        #     *[
                        #         f"arn:{stack.partition}:ec2:{stack.region}:{stack.account}:security-group/{sg.security_group_id}"
                        #         for sg in security_groups
                        #     ],
                        # ]
                    ),
                    aws_iam.PolicyStatement(
                        actions=[
                            "elasticfilesystem:ClientMount",
                            "elasticfilesystem:ClientRootAccess",
                            "elasticfilesystem:ClientWrite",
                            "elasticfilesystem:DescribeMountTargets",
                        ],
                        resources=[efs_access_point.file_system.file_system_arn],
                    ),
                ]
            role = aws_iam.Role(
                scope,
                "SMUserSetupProviderRole",
                assumed_by=aws_iam.ServicePrincipal("lambda.amazonaws.com"),
                description=(
                    "Execution role for CFN Custom Resource Lambda providing SageMaker Studio "
                    "User Setup"
                ),
                inline_policies={
                    "SageMakerLCCAdmin": aws_iam.PolicyDocument(
                        statements=inline_iam_statements,
                    ),
                },
                managed_policies=[
                    aws_iam.ManagedPolicy.from_aws_managed_policy_name(
                        "service-role/AWSLambdaBasicExecutionRole",
                    ),
                    aws_iam.ManagedPolicy.from_aws_managed_policy_name(
                        "AWSXRayDaemonWriteAccess",
                    ),
                ],
            )
        if not smcr_helper_layer:
            raise ValueError("smcr_helper_layer is required")
        on_event_handler = PythonFunction(
            scope,
            "SMUserSetupEventHandler",
            description=("CFn custom resource handler to set up SageMaker Studio User content"),
            entry=LAMBDA_PATH,
            environment_encryption=provider_function_env_encryption,
            filesystem=(
                None
                if efs_access_point is None
                else FileSystem.from_efs_access_point(efs_access_point, "/mnt/efs")
            ),
            index="main.py",
            handler="lambda_handler",
            layers=[
                smcr_helper_layer,
                # 3rd-party Lambda Layer with Git executable:
                LayerVersion.from_layer_version_arn(
                    scope,
                    "GitLayer",
                    f"arn:{stack.partition}:lambda:{stack.region}:553035198032:layer:git-lambda2:8",
                ),
            ],
            memory_size=128,
            role=role,
            runtime=LambdaRuntime.PYTHON_3_12,
            security_groups=security_groups,
            timeout=Duration.seconds(300),
            vpc=vpc,
            vpc_subnets=vpc_subnets,
        )
        super().__init__(
            scope,
            id,
            on_event_handler=on_event_handler,
            log_retention=log_retention,
            provider_function_env_encryption=provider_function_env_encryption,
            provider_function_name=provider_function_name,
            # TODO: Add support for `role` without circular dependency
            # role=role,
            security_groups=security_groups,
            total_timeout=total_timeout,
            vpc=vpc,
            vpc_subnets=vpc_subnets,
        )


class SageMakerStudioUserSetup(CustomResource):
    """AWS CDK Construct for content/setup in a SageMaker Studio User Profile

    This construct uses EFS-mounted Custom Resource Lambdas to perform setup like copying content
    into a user's SageMaker Studio home directory from S3 or Git, separately from LCC scripts.

    Each instance of a SageMakerStudioUserSetup can EITHER copy an item from S3 OR from git, into
    ONE user's home directory. If you want content across multiple users or from multiple sources,
    just create multiple instances (and preferably share one `provider` between them).
    """

    def __init__(
        self,
        scope: Construct,
        id: str,
        domain_id: str,
        home_efs_file_system_uid: Union[int, str],
        user_profile_name: str,
        vpc: aws_ec2.IVpc,
        vpc_subnets: Union[aws_ec2.SubnetSelection, Dict[str, Any]],
        *,
        authenticate_s3: Optional[bool] = None,
        content_s3_uri: Optional[str] = None,
        efs_file_system: Optional[aws_efs.IFileSystem] = None,
        efs_security_group: Optional[aws_ec2.ISecurityGroup] = None,
        enable_projects: bool = False,
        extract_content: Optional[bool] = None,
        git_checkout: Optional[str] = None,
        git_repository: Optional[str] = None,
        target_path: Optional[str] = None,
        provider: Optional[SMStudioUserSetupCustomResourceProvider] = None,
        removal_policy: Optional[RemovalPolicy] = None,
        resource_type: str = "Custom::SageMakerStudioUserContent",
        smcr_helper_layer: Optional[ILayerVersion] = None,
    ) -> None:
        """Create a SageMakerStudioUserSetup

        Parameters
        ----------
        domain_id :
            The unique ID of the SageMaker Studio Domain within which the user profile exists
        home_efs_file_system_uid :
            The POSIX EFS user ID for the given SageMaker Studio User Profile (see
            `SageMakerStudioUser` construct)
        user_profile_name :
            The (domain-unique) name of the user profile to provide setup for
        vpc :
            The VPC to which the SageMaker Domain is attached
        vpc_subnets :
            The administrative subnet(s) within which the content setup resource Lambda should
            deploy
        authenticate_s3 :
            (For loading content from S3 only), should the AWS S3 API calls use the CR Lambda's
            identity (for private buckets within your own account)? Or be unauthenticated (for
            datasets hosted in public S3 buckets)?
        content_s3_uri :
            (For loading content from S3 only), the source s3://... URI of the content to fetch
        efs_file_system :
            The home EFS file system backing this SageMaker Domain (to which a root mount point
            will be created)
        efs_security_group :
            The VPC Security Group to use for accessing EFS (i.e. the 'outbound' security group
            generated automatically by SageMaker)
        enable_projects :
            Set `True` to enable SageMaker Project Templates for the user profile, or `False` to
            leave this un-configured.
        extract_content :
            (For loading content from S3 only), set True to `unzip` the content object fetched from
            S3, or False to leave it as-is.
        git_checkout :
            (For loading content from git only), An optional `git checkout`-able reference such as
            a branch name or commit hash, to initialise the repository. If unset, the repository's
            default branch will be checked out.
        git_repository :
            (For loading content from git only), the source repository URL from which to clone
            content.
        target_path :
            The path within the user's SageMaker EFS home folder to which the content should be
            fetched/extracted.
        provider :
            Optional `SMStudioUserSetupCustomResourceProvider` if you'd like to customize provider
            configuration or re-use the Custom Resource Lambda across multiple UserSetups in your
            CDK app
        smcr_helper_layer :
            (Required if `provider` is not set) Shared Lambda layer with helper functions for
            SageMaker custom resources (see `cr_lambda_common`).
        """
        if not domain_id:
            raise ValueError("You must provide a SageMaker Studio domain_id")
        if not provider:
            provider = SMStudioUserSetupCustomResourceProvider(
                scope,
                "StudioUserSetupProvider",
                efs_file_system=efs_file_system,
                efs_security_group=efs_security_group,
                vpc=vpc,
                vpc_subnets=vpc_subnets,
                smcr_helper_layer=smcr_helper_layer,
            )

        resource_props = {
            "DomainId": domain_id,
            "EnableProjects": enable_projects,
            "HomeEfsFileSystemUid": home_efs_file_system_uid,
            "UserProfileName": user_profile_name,
        }
        if target_path:
            resource_props["TargetPath"] = target_path
        if git_checkout:
            resource_props["GitCheckout"] = git_checkout
        if git_repository:
            resource_props["GitRepository"] = git_repository
        if content_s3_uri:
            resource_props["ContentS3Uri"] = content_s3_uri
        if authenticate_s3 is not None:
            resource_props["AuthenticateS3"] = authenticate_s3
        if extract_content is not None:
            resource_props["ExtractContent"] = extract_content

        super().__init__(
            scope,
            id,
            service_token=provider.service_token,
            # pascal_case_properties=None,
            properties=resource_props,
            removal_policy=removal_policy,
            resource_type=resource_type,
        )
